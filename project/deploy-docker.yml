---
# 1. Gather load metrics on all nodes
- name: Gather load metrics
  hosts: nodes
  gather_facts: false
  tasks:
    - name: Read 1-minute load average
      ansible.builtin.shell: cut -d ' ' -f1 /proc/loadavg
      register: load_txt

    - name: Set load fact
      ansible.builtin.set_fact:
        load: "{{ load_txt.stdout | float }}"

# 2. Determine router, app and client on the controller
- name: Determine router, app and client
  hosts: controller
  gather_facts: false
  vars:
    nodes: "{{ groups['nodes'] }}"
  tasks:
    - name: Build hostâ†’load map
      ansible.builtin.set_fact:
        loads: >-
          {{
            dict(
              nodes
              | map('extract', hostvars, 'load')
              | zip(nodes)
              | map('reverse')
            )
          }}

    - name: Select router (highest load)
      ansible.builtin.set_fact:
        router: "{{ (loads | dict2items | sort(attribute='value', reverse=true))[0].key }}"

    - name: Select app (lowest load)
      ansible.builtin.set_fact:
        app: "{{ (loads | dict2items | sort(attribute='value'))[0].key }}"

    - name: Select client (remaining node)
      ansible.builtin.set_fact:
        client: "{{ (nodes | difference([router, app]))[0] }}"

    - name: Add hosts to groups
      ansible.builtin.add_host:
        name: "{{ item.node }}"
        groups: "{{ item.group }}"
      loop:
        - { node: "{{ router }}", group: router }
        - { node: "{{ app }}", group: app }
        - { node: "{{ client }}", group: client }

# 3. Configure the router node
- name: Configure router node
  hosts: router
  become: true
  tasks:
    - name: Enable IP forwarding
      ansible.builtin.sysctl:
        name: net.ipv4.ip_forward
        value: '1'
        state: present
        sysctl_set: yes

    - name: Set up NAT
      ansible.builtin.iptables:
        table: nat
        chain: POSTROUTING
        out_interface: eth0
        jump: MASQUERADE
        state: present

    - name: Save iptables
      ansible.builtin.copy:
        dest: /etc/iptables.rules
        content: "{{ lookup('pipe','iptables-save') }}"

# 4. Set default route on app and client
- name: Set default route via router
  hosts: app:client
  become: true
  vars:
    gw: "{{ hostvars[groups['router'][0]]['ansible_host'] }}"
  tasks:
    - name: Set gateway (Debian)
      when: ansible_os_family == 'Debian'
      ansible.builtin.lineinfile:
        path: /etc/network/interfaces
        regexp: '^\s*gateway'
        line: "    gateway {{ gw }}"
        create: yes

    - name: Set gateway (RedHat)
      when: ansible_os_family == 'RedHat'
      ansible.builtin.lineinfile:
        path: /etc/sysconfig/network-scripts/ifcfg-eth0
        regexp: '^GATEWAY='
        line: "GATEWAY={{ gw }}"

# 5. Deploy OrientDB via Docker
- name: Deploy OrientDB via Docker on app
  hosts: app
  become: true
  vars:
    orient_version: 3.2.39
    orient_image: "orientdb:{{ orient_version }}"
    orientdb_root_password: ChangeMe123!
  tasks:
    - name: Ensure Docker config & restart
      block:
        - name: Ensure /etc/docker exists
          ansible.builtin.file:
            path: /etc/docker
            state: directory
            mode: '0755'

        - name: Disable Astra scan
          ansible.builtin.copy:
            dest: /etc/docker/daemon.json
            content: |
              {
                "astra-sec-level": 6
              }

        - name: Restart Docker
          ansible.builtin.service:
            name: docker
            state: restarted
      when: ansible_os_family in ['Debian','RedHat']

    - name: Install Docker on Debian
      ansible.builtin.apt:
        name: docker.io
        state: present
        update_cache: yes
      when: ansible_os_family == 'Debian'

    - name: Install Docker on RedHat
      ansible.builtin.yum:
        name: docker
        state: present
      when: ansible_os_family == 'RedHat'

    - name: Start Docker service
      ansible.builtin.service:
        name: docker
        state: started
        enabled: yes

    - name: Ensure OrientDB container running
      ansible.builtin.shell: |
        if docker ps --filter name=orientdb --filter status=running | grep -qw orientdb; then exit 0; fi
        if docker ps -a --filter name=orientdb | grep -qw orientdb; then docker start orientdb; exit 0; fi
        docker run -d --name orientdb \
          -e ORIENTDB_ROOT_PASSWORD={{ orientdb_root_password }} \
          -p 2480:2480 -p 2424:2424 \
          --restart always {{ orient_image }}
      args:
        executable: /bin/bash

# 6. Firewall rules to restrict OrientDB access
- name: Restrict OrientDB access on app
  hosts: app
  become: true
  vars:
    client_ip: "{{ hostvars[groups['client'][0]]['ansible_host'] }}"
  tasks:
    - ansible.builtin.iptables:
        chain: INPUT
        table: filter
        flush: yes

    - ansible.builtin.iptables:
        chain: INPUT
        ctstate: RELATED,ESTABLISHED
        jump: ACCEPT

    - ansible.builtin.iptables:
        chain: INPUT
        protocol: tcp
        destination_port: 22
        jump: ACCEPT

    - ansible.builtin.iptables:
        chain: INPUT
        in_interface: lo
        jump: ACCEPT

    - ansible.builtin.iptables:
        chain: INPUT
        protocol: tcp
        destination_port: 2480
        source: "{{ client_ip }}"
        jump: ACCEPT

    - ansible.builtin.iptables:
        chain: INPUT
        jump: DROP

# 7. Test access to OrientDB from client
- name: Test OrientDB from client
  hosts: client
  become: true
  vars:
    app_ip: "{{ hostvars[groups['app'][0]]['ansible_host'] }}"
  tasks:
    - ansible.builtin.lineinfile:
        path: /etc/hosts
        line: "{{ app_ip }} orientdb.local"
        create: yes

    - ansible.builtin.uri:
        url: http://orientdb.local:2480
        method: GET
      register: result

    - ansible.builtin.debug:
        msg: "OrientDB status: {{ result.status }}"
